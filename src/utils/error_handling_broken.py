"""
Comprehensive Error Handling and Graceful Degradation

Provides robust error handling, retry mechanisms, and graceful fallbacks
for the insurance claim negotiation system.
"""

import logging
import time
import functools
from typing import Callable, Any, Dict, Optional, List, Type
from datetime import datetime, timedelta
import traceback

logger = logging.getLogger(__name__)

class SystemError(Exception):
    """Base exception for system errors"""
    def __init__(self, message: str, error_code: str = "SYSTEM_ERROR", details: Dict[str, Any] = None):
        super().__init__(message)
        self.error_code = error_code
        self.details = details or {}
        self.timestamp = datetime.now()

class APIError(SystemError):
    """API-related errors"""
    def __init__(self, service: str, status_code: int, message: str, details: Dict[str, Any] = None):
        super().__init__(f"{service} API error: {message}", f"API_ERROR_{service.upper()}", details)
        self.service = service
        self.status_code = status_code

class ToolExecutionError(SystemError):
    """Tool execution errors"""
    def __init__(self, tool_name: str, message: str, details: Dict[str, Any] = None):
        super().__init__(f"Tool '{tool_name}' execution failed: {message}", f"TOOL_ERROR_{tool_name.upper()}", details)
        self.tool_name = tool_name

class VoiceProcessingError(SystemError):
    """Voice processing errors"""
    def __init__(self, stage: str, message: str, details: Dict[str, Any] = None):
        super().__init__(f"Voice processing error at {stage}: {message}", f"VOICE_ERROR_{stage.upper()}", details)
        self.stage = stage

def retry_with_exponential_backoff(
    max_retries: int = 3,
    base_delay: float = 1.0,
    max_delay: float = 60.0,
    exponential_base: float = 2.0,
    exceptions: tuple = (Exception,)
):\n    \"\"\"Decorator for retrying functions with exponential backoff\"\"\"\n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs) -> Any:\n            last_exception = None\n            \n            for attempt in range(max_retries + 1):\n                try:\n                    return func(*args, **kwargs)\n                except exceptions as e:\n                    last_exception = e\n                    \n                    if attempt == max_retries:\n                        logger.error(f\"Function {func.__name__} failed after {max_retries} retries: {str(e)}\")\n                        raise e\n                    \n                    delay = min(base_delay * (exponential_base ** attempt), max_delay)\n                    logger.warning(f\"Function {func.__name__} failed (attempt {attempt + 1}/{max_retries + 1}), retrying in {delay:.1f}s: {str(e)}\")\n                    time.sleep(delay)\n            \n            # This should never be reached, but just in case\n            raise last_exception\n        \n        return wrapper\n    return decorator

def graceful_fallback(fallback_func: Callable, exceptions: tuple = (Exception,)):\n    \"\"\"Decorator for graceful fallback to alternative function\"\"\"\n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs) -> Any:\n            try:\n                return func(*args, **kwargs)\n            except exceptions as e:\n                logger.warning(f\"Function {func.__name__} failed, using fallback: {str(e)}\")\n                try:\n                    return fallback_func(*args, **kwargs)\n                except Exception as fallback_error:\n                    logger.error(f\"Fallback function also failed: {str(fallback_error)}\")\n                    raise e  # Raise original exception\n        \n        return wrapper\n    return decorator

class ErrorRecoveryManager:\n    \"\"\"Manages error recovery and system health\"\"\"\n    \n    def __init__(self):\n        self.error_counts: Dict[str, int] = {}\n        self.last_errors: Dict[str, datetime] = {}\n        self.system_health: Dict[str, str] = {\n            \"voice_processing\": \"healthy\",\n            \"emotion_analysis\": \"healthy\", \n            \"policy_lookup\": \"healthy\",\n            \"claim_validation\": \"healthy\",\n            \"settlement_generation\": \"healthy\",\n            \"overall_system\": \"healthy\"\n        }\n        self.degraded_mode = False\n        self.circuit_breakers: Dict[str, Dict[str, Any]] = {}\n    \n    def record_error(self, component: str, error: Exception, context: Dict[str, Any] = None) -> None:\n        \"\"\"Record an error for tracking and health monitoring\"\"\"\n        error_key = f\"{component}_{type(error).__name__}\"\n        \n        # Update error counts\n        self.error_counts[error_key] = self.error_counts.get(error_key, 0) + 1\n        self.last_errors[error_key] = datetime.now()\n        \n        # Update component health\n        if self.error_counts[error_key] >= 3:\n            self.system_health[component] = \"degraded\"\n            \n        if self.error_counts[error_key] >= 5:\n            self.system_health[component] = \"failed\"\n            self._activate_circuit_breaker(component)\n        \n        # Log error details\n        error_details = {\n            \"component\": component,\n            \"error_type\": type(error).__name__,\n            \"error_message\": str(error),\n            \"error_count\": self.error_counts[error_key],\n            \"context\": context or {},\n            \"timestamp\": datetime.now().isoformat()\n        }\n        \n        logger.error(f\"Error recorded for {component}: {error_details}\")\n        \n        # Check if system should enter degraded mode\n        self._check_system_health()\n    \n    def record_success(self, component: str) -> None:\n        \"\"\"Record successful operation to improve health status\"\"\"\n        # Reset error counts on success\n        error_keys_to_reset = [k for k in self.error_counts.keys() if k.startswith(component)]\n        for key in error_keys_to_reset:\n            if self.error_counts[key] > 0:\n                self.error_counts[key] = max(0, self.error_counts[key] - 1)\n        \n        # Improve health status\n        if self.system_health.get(component) == \"failed\" and self.error_counts.get(component, 0) == 0:\n            self.system_health[component] = \"degraded\"\n        elif self.system_health.get(component) == \"degraded\" and self.error_counts.get(component, 0) == 0:\n            self.system_health[component] = \"healthy\"\n            self._deactivate_circuit_breaker(component)\n    \n    def is_component_healthy(self, component: str) -> bool:\n        \"\"\"Check if a component is healthy\"\"\"\n        return self.system_health.get(component, \"healthy\") in [\"healthy\", \"degraded\"]\n    \n    def get_fallback_strategy(self, component: str, operation: str) -> str:\n        \"\"\"Get fallback strategy for failed component\"\"\"\n        fallback_strategies = {\n            \"voice_processing\": {\n                \"emotion_analysis\": \"use_text_analysis\",\n                \"audio_recording\": \"use_text_input\",\n                \"speech_synthesis\": \"text_only_response\"\n            },\n            \"emotion_analysis\": {\n                \"hume_api\": \"use_sentiment_analysis\",\n                \"sentiment_analysis\": \"assume_neutral_emotion\"\n            },\n            \"policy_lookup\": {\n                \"database_query\": \"use_cached_policies\",\n                \"api_call\": \"use_mock_data\"\n            },\n            \"claim_validation\": {\n                \"fraud_detection\": \"basic_validation_only\",\n                \"coverage_check\": \"assume_covered\"\n            },\n            \"settlement_generation\": {\n                \"precedent_analysis\": \"use_standard_rates\",\n                \"compliance_check\": \"manual_review_required\"\n            }\n        }\n        \n        return fallback_strategies.get(component, {}).get(operation, \"manual_review_required\")\n    \n    def _activate_circuit_breaker(self, component: str) -> None:\n        \"\"\"Activate circuit breaker for failing component\"\"\"\n        self.circuit_breakers[component] = {\n            \"activated\": True,\n            \"activation_time\": datetime.now(),\n            \"retry_after\": datetime.now() + timedelta(minutes=5)\n        }\n        \n        logger.warning(f\"Circuit breaker activated for {component}\")\n    \n    def _deactivate_circuit_breaker(self, component: str) -> None:\n        \"\"\"Deactivate circuit breaker when component recovers\"\"\"\n        if component in self.circuit_breakers:\n            del self.circuit_breakers[component]\n            logger.info(f\"Circuit breaker deactivated for {component}\")\n    \n    def _check_system_health(self) -> None:\n        \"\"\"Check overall system health and activate degraded mode if needed\"\"\"\n        failed_components = [comp for comp, status in self.system_health.items() \n                           if status == \"failed\" and comp != \"overall_system\"]\n        \n        degraded_components = [comp for comp, status in self.system_health.items() \n                             if status == \"degraded\" and comp != \"overall_system\"]\n        \n        if len(failed_components) >= 2:\n            self.system_health[\"overall_system\"] = \"failed\"\n            self.degraded_mode = True\n            logger.critical(f\"System entering failed state. Failed components: {failed_components}\")\n        elif len(failed_components) >= 1 or len(degraded_components) >= 3:\n            self.system_health[\"overall_system\"] = \"degraded\"\n            self.degraded_mode = True\n            logger.warning(f\"System entering degraded mode. Failed: {failed_components}, Degraded: {degraded_components}\")\n        else:\n            self.system_health[\"overall_system\"] = \"healthy\"\n            self.degraded_mode = False\n\n    def get_system_status_report(self) -> Dict[str, Any]:\n        \"\"\"Get comprehensive system status report\"\"\"\n        return {\n            \"overall_health\": self.system_health[\"overall_system\"],\n            \"degraded_mode\": self.degraded_mode,\n            \"component_health\": {k: v for k, v in self.system_health.items() if k != \"overall_system\"},\n            \"active_circuit_breakers\": list(self.circuit_breakers.keys()),\n            \"error_counts\": self.error_counts,\n            \"last_check\": datetime.now().isoformat(),\n            \"recommendations\": self._generate_recommendations()\n        }\n    \n    def _generate_recommendations(self) -> List[str]:\n        \"\"\"Generate recommendations based on current system state\"\"\"\n        recommendations = []\n        \n        failed_components = [comp for comp, status in self.system_health.items() \n                           if status == \"failed\" and comp != \"overall_system\"]\n        \n        if failed_components:\n            recommendations.append(f\"Immediate attention required for: {', '.join(failed_components)}\")\n        \n        if self.degraded_mode:\n            recommendations.append(\"System is operating in degraded mode - consider manual intervention\")\n        \n        if len(self.circuit_breakers) > 0:\n            recommendations.append(f\"Circuit breakers active for: {', '.join(self.circuit_breakers.keys())}\")\n        \n        return recommendations

# Global error recovery manager instance\nerror_recovery = ErrorRecoveryManager()

def safe_execute(component: str, operation: str = \"general\"):\n    \"\"\"Decorator for safe execution with error tracking\"\"\"\n    def decorator(func: Callable) -> Callable:\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs) -> Any:\n            try:\n                result = func(*args, **kwargs)\n                error_recovery.record_success(component)\n                return result\n            except Exception as e:\n                error_recovery.record_error(component, e, {\n                    \"function\": func.__name__,\n                    \"operation\": operation,\n                    \"args_count\": len(args),\n                    \"kwargs_keys\": list(kwargs.keys())\n                })\n                \n                # Generate user-friendly error response\n                fallback_strategy = error_recovery.get_fallback_strategy(component, operation)\n                \n                if fallback_strategy == \"manual_review_required\":\n                    raise SystemError(\n                        f\"Service temporarily unavailable. Please contact support.\",\n                        f\"SERVICE_UNAVAILABLE_{component.upper()}\",\n                        {\"original_error\": str(e), \"fallback_strategy\": fallback_strategy}\n                    )\n                else:\n                    logger.warning(f\"Using fallback strategy '{fallback_strategy}' for {component}.{operation}\")\n                    raise e  # Let the calling code handle the fallback\n        \n        return wrapper\n    return decorator\n\ndef get_user_friendly_error_message(error: Exception) -> str:\n    \"\"\"Convert technical errors to user-friendly messages\"\"\"\n    \n    error_messages = {\n        \"APIError\": \"We're experiencing connectivity issues. Please try again in a moment.\",\n        \"VoiceProcessingError\": \"There was an issue processing your voice. You can continue with text input.\",\n        \"ToolExecutionError\": \"We're having trouble accessing some services. Your request may take longer to process.\",\n        \"SystemError\": \"We're experiencing technical difficulties. Our team has been notified.\"\n    }\n    \n    error_type = type(error).__name__\n    \n    if hasattr(error, 'error_code') and \"API_ERROR\" in error.error_code:\n        return \"We're having trouble connecting to our services. Please try again shortly.\"\n    \n    return error_messages.get(error_type, \"An unexpected error occurred. Please contact support if this persists.\")\n\ndef create_error_response(error: Exception, context: Dict[str, Any] = None) -> Dict[str, Any]:\n    \"\"\"Create standardized error response\"\"\"\n    return {\n        \"status\": \"error\",\n        \"error_type\": type(error).__name__,\n        \"error_message\": get_user_friendly_error_message(error),\n        \"error_code\": getattr(error, 'error_code', 'UNKNOWN_ERROR'),\n        \"timestamp\": datetime.now().isoformat(),\n        \"context\": context or {},\n        \"system_health\": error_recovery.get_system_status_report(),\n        \"recommendations\": {\n            \"user_action\": \"Please try again. If the problem persists, contact support.\",\n            \"escalation_needed\": error_recovery.degraded_mode\n        }\n    }